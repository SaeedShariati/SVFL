#include <tomcrypt.h>
#include <gmp.h>
#include <pbc/pbc.h>
#include <unistd.h>
#include <string.h>
#include <time.h>
#include <math.h>
#include <stdbool.h>
#include "CryptoPrimitivesV1.h"



//############ Time Measurement ############
void Time_Measure(DscTimeMeasure *time)
{
    time->seconds = time->end.tv_sec - time->start.tv_sec;
    time->nanoseconds = time->end.tv_nsec - time->start.tv_nsec;

    if (time->nanoseconds < 0) {
        time->seconds -= 1;
        time->nanoseconds += 1000000000;
    }

   
    time->milliseconds = time->seconds * 1000 + time->nanoseconds / 1000000;
    time->microseconds = time->seconds * 1000000 + time->nanoseconds / 1000;
}
//############################################


//############ Space Measurement ############
void Space_Measure(DscSpaceMeasure *space)
{
   space->sizeInBytes=element_length_in_bytes(space->var);
   space->sizeInBit=space->sizeInBytes*8;
   space->sizeInKBytes=space->sizeInBytes/1024.0;
   space->sizeInMBytes=space->sizeInBytes/(1024.0*1024.0);
}
//############################################


//############ HMAC=(KeyGen,Eval) ############
void HMAC_Config(DscHMAC *hmac, int secparam)
{
    hmac->secparam=secparam;
    hmac->plaintextInput = (unsigned char *)"I am a computer science student";
    //hmac->plaintextInput="I am a computer science student"; 
    hmac->DigestOutput=malloc(hmac->secparam);
    hmac->key=malloc(hmac->secparam);
}
void HMAC_KeyGen(DscHMAC *hmac)
{
if (rng_get_bytes(hmac->key, hmac->secparam, NULL) != hmac->secparam)
 {
        printf("Error generating random key\n");
 }
}
void HMAC_Eval(DscHMAC *hmac)
 {
    int err;
    
    register_hash(&sha256_desc);
    
    err = hmac_memory(find_hash("sha256"), hmac->key,hmac->secparam,
                      hmac->plaintextInput,strlen((const char *)hmac->plaintextInput),
                      hmac->DigestOutput, &(hmac->output_len));
    

    if (err != CRYPT_OK) {
        printf("Error performing HMAC: %s\n", error_to_string(err));
    }
 
}
//############################################


//############ PRF=(KeyGen,Eval) #############
void PRF_Config(DscPRF *prf,int secparam)
{
    prf->secparam=secparam;
    prf->plaintextInput=malloc(prf->secparam);
    strcpy((char *)prf->plaintextInput, "I am a student");
    prf->randomOutput=malloc(prf->secparam);
    prf->key=malloc(prf->secparam);
    
}
void PRF_KeyGen(DscPRF *prf)
{
if (rng_get_bytes(prf->key, prf->secparam, NULL) != prf->secparam)
 {
        printf("Error generating random key\n");
 }
}
void PRF_Eval(DscPRF *prf)
{
    int err;
    //unsigned long *tmp;

    unsigned long output_len=prf->secparam;
    register_hash(&sha256_desc);
    err = hmac_memory(find_hash("sha256"), prf->key,prf->secparam,
                      prf->plaintextInput, strlen((const char *)prf->plaintextInput),
                      prf->randomOutput, &(output_len));

    if (err != CRYPT_OK) {
        printf("Error performing PRF: %s\n", error_to_string(err));
    }
}



//############ PRG=(SeedGen,Eval) ############
void PRG_Config(DscPRG *prg, int secparam, int size)
{
    prg->secparam=secparam;
    prg->size=size;
}
void PRG_SeedGen(DscPRG *prg)
{
    (&(prg->hmac))->secparam=16;
    (&(prg->hmac))->plaintextInput = (unsigned char *)malloc(strlen("An inital value          ") + 1);
    strcpy((&(prg->hmac))->plaintextInput, "An inital value          ");
    (&(prg->hmac))->DigestOutput=malloc((&(prg->hmac))->secparam);
    (&(prg->hmac))->key=malloc((&(prg->hmac))->secparam);
    //(&(prg->hmac))->output_len = 16;
    prg->randomOutput=malloc(prg->size);  
    HMAC_KeyGen((&(prg->hmac)));
}
void PRG_Eval(DscPRG *prg) {
    
    unsigned long generated = 0;       // Counter for generated bytes
    unsigned long remaining = prg->size; // Remaining bytes to generate
    //unsigned char hmac[sizeof(prg->seed)];  // Buffer for HMAC output
    //unsigned long hmac_len = sizeof(prg->seed);        // Length of HMAC output (SHA-256 produces 32 bytes)
    unsigned long counter=0;              // Counter for HMAC input
    size_t input_len = strlen((char *)prg->hmac.plaintextInput);
    size_t counter_size = sizeof(counter);

    char counter_str[5];
    unsigned long temp_output_len = (&(prg->hmac))->secparam;
    unsigned long bytes_to_copy = 0;
    while (remaining > 0) {
        // Use the generated count as input for HMAC
        //counter = generated;
        //printf("\nCounter: %d\n", counter); //(prg->hmac).secparam);
        sprintf(counter_str, "%d", counter);
        memcpy(prg->hmac.plaintextInput + 16, &counter_str, 5);
        printf("plaintext:\n %s",prg->hmac.plaintextInput);
        // Compute HMAC with the current counter as input        
        HMAC_Eval(&(prg->hmac));
        
        // Determine how many bytes to copy to output
        bytes_to_copy = (remaining < temp_output_len) ? remaining : temp_output_len;
        printf("\nDetermine how many bytes to copy to output");
        printf("\nbytes_to_copy: %d\n", bytes_to_copy);
        fflush(stdout);
        
        // Copy the HMAC output to the final output buffer {
        memcpy(prg->randomOutput + generated, prg->hmac.DigestOutput, bytes_to_copy);

        printf("\nCopy the HMAC output to the final output buffer");
        
  

        // Update counters
        generated += bytes_to_copy;
        remaining -= bytes_to_copy;

        counter++;
    }

    // Update the output length
    //prg->output_len = generated;
}
//############################################


//############ Hash=(Eval) ############
void Hash_Config(DscHash *hash,int secparam)
{
    /*SHA1:   register_hash (&sha1_desc);
    SHA224: register_hash (&sha224_desc);
    SHA256: register_hash (&sha256_desc);
    SHA384: register_hash (&sha384_desc);
    SHA512: register_hash (&sha512_desc);
    MD2:    register_hash (&md2_desc);
    MD4:    register_hash (&md4_desc);
    MD5:    register_hash (&md5_desc);*/
    char *str="Example input data";
    assert(hash != NULL);
    //if (!hash) { perror("malloc failed"); exit(1); }
    hash->plaintextInput = malloc(strlen(str) + 1); // allocate string copy
    //if (!hash->plaintextInput) { perror("malloc failed"); exit(1); }
    strcpy((char *)hash->plaintextInput,str);

    hash->secparam=secparam;
    hash->DigestOutput=malloc(hash->secparam);// Adjust buffer size for safety
    register_hash (&sha256_desc);
    hash->hash_name="sha256";
}
void Hash_Eval(DscHash *hash) {
    int err, hash_idx;
    
    // Find the hash function by name

    hash_idx = find_hash(hash->hash_name);
    if (hash_idx == -1) {
        printf("Invalid hash function name: %s\n", hash->hash_name);
        exit(EXIT_FAILURE);
    }

    // Set the output length for the found hash function
    hash->output_len = hash_descriptor[hash_idx].hashsize;

    // Compute the hash
    err = hash_memory(hash_idx, hash->plaintextInput, strlen((const char *)hash->plaintextInput) - 1, hash->DigestOutput, &(hash->output_len));    if (err != CRYPT_OK) {
        printf("Error performing hash: %s\n", error_to_string(err));
        exit(EXIT_FAILURE);
    }
}
//###############################


//############ GroupGen (GMP) ############
void GroupGen_Config(DscGrp *grp)
{
    grp->secparam=512;
    mpz_init(grp->prime);
    mpz_init(grp->generator);
    mpz_init(grp->order);
}
void generate_prime(DscGrp *grp) {
    gmp_randinit_default(grp->state);
    gmp_randseed_ui(grp->state, time(NULL)); // Seed the random number generator

    // Generate a random prime number
    mpz_urandomb(grp->prime, grp->state, grp->secparam);
    mpz_nextprime(grp->prime, grp->prime); // Find the next prime number
}
void find_generator(DscGrp *grp) {
    mpz_sub_ui(grp->order, grp->prime, 1); // Order of the group is p - 1

    // Find a generator (this is a simple method, not optimized)
    for (mpz_set_ui(grp->generator, 2); mpz_cmp(grp->generator, grp->prime) < 0; mpz_add_ui(grp->generator, grp->generator, 1)) {
        mpz_t power;
        mpz_init(power);
        mpz_powm(power, grp->generator, grp->order, grp->prime); // g^(p-1) mod p

        if (mpz_cmp_ui(power, 1) == 0) {
            // Found a generator
            mpz_clear(power);
            return;
        }
        mpz_clear(power);
    }

    mpz_set_ui(grp->generator, 0); // If no generator found, set to 0
}
void GroupGen(DscGrp *grp)
{
    generate_prime(grp);
    find_generator(grp);
}
//###############################


//############ BGroupGen  ############
void BGroupGen_Config(DscBGrp *bgrp)
{
    bgrp->paramSize=2048;
    bgrp->paramAddress="d224.param";
}
void BGroupGen(DscBGrp *bgrp)
{
    char param[bgrp->paramSize]; // Adjust size if needed
    FILE *param_file;

    // Load parameters from d224.param file
    param_file = fopen(bgrp->paramAddress, "r");
    if (!param_file) {
        pbc_die("Error opening param file.");
    }
    size_t count = fread(param, 1, sizeof(param), param_file);
    if (count == 0) 
    {
        pbc_die("Error reading param file.");
        fclose(param_file);
    }
    pairing_init_set_buf(bgrp->pairing, param, count);
    fclose(param_file);
    mpz_init(bgrp->order);
    mpz_set(bgrp->order, (bgrp->pairing)->r);
    
    element_init_G1(bgrp->g1, bgrp->pairing);
    element_init_G2(bgrp->g2, bgrp->pairing);
    element_init_GT(bgrp->gt, bgrp->pairing);
    element_random(bgrp->g1);
    element_random(bgrp->g2);
    element_random(bgrp->gt);

    element_init_G1(bgrp->rg1, bgrp->pairing);
    element_init_G2(bgrp->rg2, bgrp->pairing);
    element_init_GT(bgrp->rgt, bgrp->pairing);
    element_init_Zr(bgrp->rz,bgrp->pairing);
    element_random(bgrp->rg1);
    element_random(bgrp->rg2);
    element_random(bgrp->rgt);
    element_random(bgrp->rz);
}
//###############################



//############ SKE=(KeyGen,Enc,Dec) (AES+CBC (Blocksize=16B)) ############
void SKE_Config(DscAES *aes,int secparam) {
    aes->secparam=secparam;
    char *str="I am a computer science student";
    aes->plaintextInput=malloc(strlen(str) * sizeof(char));
    strcpy(aes->plaintextInput,str); 
    aes->plaintextOutput=malloc(strlen(str) * sizeof(char));
    aes->ciphertextOutput=malloc(2*strlen(str) * sizeof(char));
    aes->key=malloc(((aes->secparam)+1)* sizeof(char));
    aes->iv=malloc((aes->secparam)* sizeof(char));
    PADDING_Config(&(aes->padd));
    }
void SKE_KeyGen(DscAES *aes)
{
if (rng_get_bytes((unsigned char *)aes->key, aes->secparam, NULL) != aes->secparam)
 {
        printf("Error generating random key\n");
 }

 }
 void SKE_ENC(DscAES *aes)
 {
    int err;
    symmetric_CBC cbc;

    strcpy(aes->padd.mainMessage,aes->plaintextInput);
    PADDING_Message(&(aes->padd));
    char *temp=realloc(aes->ciphertextOutput, (strlen(aes->padd.paddedMessage))*sizeof(char));
    if (temp !=NULL){
        aes->ciphertextOutput=temp;
    }

    if (register_cipher(&aes_desc) == -1){
        printf("Error registering cipher.\n");
    }

    // Initialize CBC mode
if ((err = cbc_start(find_cipher("aes"), (const unsigned char *)aes->iv, (const unsigned char *)aes->key, aes->secparam, 0, &cbc)) != CRYPT_OK) {        printf("cbc_start error: %s\n", error_to_string(err));
    }

    // Encrypt the plaintext
    //printf("\nLength padded is: %ld\n",strlen(aes->padd.paddedMessage));
        //aes->ciphertextOutput=malloc(2*strlen(aes->padd.paddedMessage) * sizeof(char));
if ((err = cbc_encrypt((const unsigned char *)aes->padd.paddedMessage, (unsigned char *)aes->ciphertextOutput, strlen(aes->padd.paddedMessage), &cbc)) != CRYPT_OK) {        printf("cbc_encrypt error: %s\n", error_to_string(err));
    }
    
    // Done with CBC mode for encryption
    if ((err = cbc_done(&cbc)) != CRYPT_OK) {
        printf("cbc_done error: %s\n", error_to_string(err));
    }

 }
 void SKE_DEC(DscAES *aes)
 {
    int err;
    symmetric_CBC cbc;
    /* *temp4=realloc(aes->ciphertextOutput, (strlen(aes->padd.paddedMessage))*sizeof(char));

    if (temp4 !=NULL){
        aes->ciphertextOutput=temp4;
    }*/

     // Initialize CBC mode for decryption
if ((err = cbc_start(find_cipher("aes"), (const unsigned char *)aes->iv, (const unsigned char *)aes->key, aes->secparam, 0, &cbc)) != CRYPT_OK) {        printf("cbc_start error: %s\n", error_to_string(err));
    }

    // Decrypt the ciphertext
    //aes->padd.paddedMessage=malloc(strlen((aes->padd.paddedMessage)) * sizeof(char));
if ((err = cbc_decrypt((const unsigned char *)aes->ciphertextOutput, (unsigned char *)aes->padd.paddedMessage, strlen(aes->padd.paddedMessage), &cbc)) != CRYPT_OK) {        printf("cbc_decrypt error: %s\n", error_to_string(err));
    }

    // Done with CBC mode for decryption
    if ((err = cbc_done(&cbc)) != CRYPT_OK) {
        printf("cbc_done error: %s\n", error_to_string(err));
    }


    UNPADDING_Message(&(aes->padd));
    char *temp=realloc(aes->plaintextOutput, strlen(aes->padd.unpaddedMessage));
    if (temp !=NULL){
        aes->plaintextOutput=temp;
    }
    strcpy(aes->plaintextOutput,aes->padd.unpaddedMessage);
 }
//###############################


//###### PKE=(KeyGen,Enc,Dec) (Elgamel)
void PKE_Config(DscElg *elg)
{
    GroupGen_Config(&(elg->grp));
    elg->grp.secparam=256;
    char *str="This is example";
    elg->plaintextInput=malloc(strlen(str));
    strcpy(elg->plaintextInput,str);
    elg->plaintextOutput=malloc(2*strlen(str));
    mpz_init(elg->c1);
    mpz_init(elg->c2);
    mpz_init(elg->input);
    mpz_init(elg->pkey);
    mpz_init(elg->skey);
}
void PKE_KeyGen(DscElg *elg)
{
    GroupGen(&(elg->grp));
    mpz_urandomm(elg->skey,elg->grp.state, elg->grp.generator);
    mpz_powm(elg->pkey, elg->grp.generator, elg->skey, elg->grp.prime);
}
void PKE_ENC(DscElg *elg)
{
    mpz_import(elg->input, strlen(elg->plaintextInput), 1, sizeof(char), 0, 0, elg->plaintextInput);

    mpz_t r;
    mpz_init(r); 
    mpz_urandomm(r,elg->grp.state, elg->grp.generator);

    // c1 = g^k mod p
    mpz_powm(elg->c1, elg->grp.generator,r, elg->grp.prime);

    // c2 = m * y^k mod p
    mpz_powm(elg->c2, elg->pkey, r, elg->grp.prime);
    mpz_mul(elg->c2, elg->c2, elg->input);
    mpz_mod(elg->c2, elg->c2, elg->grp.prime);
}
void PKE_DEC(DscElg *elg)
{
    mpz_t s, m;
    mpz_init(s);
    mpz_init(m);
    
    mpz_powm(s, elg->c1, elg->skey, elg->grp.prime);

    mpz_invert(s, s, elg->grp.prime);
    mpz_mul(m, elg->c2, s);
    mpz_mod(m, m, elg->grp.prime);
    
    size_t count;
    mpz_export(elg->plaintextOutput, &count, 1, sizeof(char), 0, 0, m);
    elg->plaintextOutput[count] = '\0';
}
//###############################


//################ Ds=(Gen,Sign,vrfy) (Schnorr signature scheme) 
void DS_Config(DscDS *ds)
{
    char *str="Iammojtaba";
    ds->plaintextInput=malloc(strlen(str)*sizeof(char));
    strcpy(ds->plaintextInput,str);
    ds->isValid=false;
    Hash_Config(&(ds->hash),32);
    GroupGen_Config(&(ds->grp));
    ds->grp.secparam=512;
    mpz_init(ds->skey);
    mpz_init(ds->pkey);
    mpz_init(ds->tag1);
    mpz_init(ds->tag2);
}
void DS_KeyGen(DscDS *ds)
{
    GroupGen(&(ds->grp));
    mpz_urandomm(ds->skey,ds->grp.state, ds->grp.generator);
    mpz_powm(ds->pkey, ds->grp.generator, ds->skey, ds->grp.prime);
}
void DS_Sign(DscDS *ds)
{
    char *str=malloc(64*sizeof(char));
    mpz_t k;
    mpz_init(k); 
    mpz_urandomm(k,ds->grp.state, ds->grp.generator);


     mpz_t I;
     mpz_init(I); 
     mpz_powm(I, ds->grp.generator, k, ds->grp.prime);

    size_t count;
    //mpz_export(str, &count, 1, sizeof(char), 0, 0, I);
    gmp_sprintf(str,"%02x",I);



    sprintf(str,"%s%s",str,ds->plaintextInput);
 


    char *temp2=realloc(ds->hash.plaintextInput, strlen(str));
    if (temp2 !=NULL){
        ds->hash.plaintextInput = (unsigned char *)temp2;
    }

    strcpy((char *)ds->hash.plaintextInput,str);
    Hash_Eval(&(ds->hash));


    mpz_import(ds->tag1, strlen((const char *)(&(ds->hash))->DigestOutput), 1, sizeof(char), 0, 0, (&(ds->hash))->DigestOutput);

    mpz_mul(ds->tag2, ds->tag1, ds->skey);
    mpz_add(ds->tag2,ds->tag2,k);
    
    mpz_t q;
    mpz_init(q); 
    mpz_sub_ui(q,ds->grp.prime,1);
    mpz_mod(ds->tag2, ds->tag2, q);
}
void DS_Vrfy(DscDS *ds)
{
    char *str=malloc(64 * sizeof(char));

    mpz_t temp1,temp2,temp3,temp4;
    mpz_init(temp1);
    mpz_init(temp2);
    mpz_init(temp3);
    mpz_init(temp4); 

    mpz_powm(temp1, ds->grp.generator, ds->tag2, ds->grp.prime);
    
    mpz_neg(temp4,ds->tag1);
    mpz_powm(temp2, ds->pkey, temp4, ds->grp.prime);

    mpz_mul(temp3, temp1, temp2);
    mpz_mod(temp3, temp3, ds->grp.prime);
    

    size_t count;
    //mpz_export(str, &count, 1, sizeof(char), 0, 0, temp3);
    gmp_sprintf(str,"%02x",temp3);



    sprintf(str,"%s%s",str,ds->plaintextInput);
    //strcat(str,ds->plaintextInput);
    

  char *temp=realloc(ds->hash.plaintextInput, strlen(str));
    if (temp !=NULL){
        ds->hash.plaintextInput=(unsigned char *)temp;
    }
        strcpy((char *)ds->hash.plaintextInput, str);
    Hash_Eval(&(ds->hash));
    
   
    //mpz_import(temp4, strlen((&(ds->hash))->DigestOutput), 1, sizeof(char), 0, 0, (&(ds->hash))->DigestOutput);
    mpz_import(temp4, strlen((const char *)(&(ds->hash))->DigestOutput), 1, sizeof(char), 0, 0, (const void *)(&(ds->hash))->DigestOutput);


    if (mpz_cmp(temp4,ds->tag1)==0)
    {
        ds->isValid=true;
    }
    else
    {
        ds->isValid=false;
    }
}
//###############################


//################ Padding=(PADDING_Message,UNPADDING_Message) (PKCS7_PADDING)
void PADDING_Config(DscPADD *padd)
{
    padd->blockSize=16;
    char *str="This is a sample message for test";
    padd->mainMessage=malloc(strlen(str) *sizeof(char));
    strcpy(padd->mainMessage,str);
    padd->paddedMessage=malloc((strlen(str)+16) *sizeof(char));
    padd->unpaddedMessage=malloc(strlen(str) *sizeof(char));
}
void PADDING_Message(DscPADD *padd){
    unsigned long data_len, padded_len;
    char *temp=malloc(strlen(padd->mainMessage)*sizeof(char));
    strcpy(temp,padd->mainMessage);
    data_len=strlen(temp);

    unsigned long padding_len = padd->blockSize - (data_len % padd->blockSize);
    padded_len = data_len + padding_len;
    
    
    char *padded_data = realloc(padd->paddedMessage,(padded_len+1)*sizeof(char));
    
    if (padded_data !=NULL){
        padd->paddedMessage=padded_data;
        memcpy(padd->paddedMessage, temp, data_len);
        memset(padd->paddedMessage + data_len, (char)padding_len, padding_len);
        memset(padd->paddedMessage + padded_len, '\0', 1);
    }
}
void UNPADDING_Message(DscPADD *padd) {
    unsigned long data_len, padded_len;
    char *temp=malloc(strlen(padd->paddedMessage)*sizeof(char));
    strcpy(temp,padd->paddedMessage);

    padded_len=(int)padd->paddedMessage[(strlen(padd->paddedMessage))-1];
    data_len=strlen(padd->paddedMessage)-padded_len;
    
    char *unpadded_data = realloc(padd->unpaddedMessage,(data_len+1)*sizeof(char));
    
    if (unpadded_data !=NULL){
        padd->unpaddedMessage=unpadded_data;
        memcpy(padd->unpaddedMessage, temp, data_len);
    }
    padd->unpaddedMessage[data_len]='\0';
}
//###############################


//###### Thrss=(Share,ReConst) (Shamir Secret Sharing)
void generate_random_mpz(DscThss *thss, mpz_ptr rndelement) {
    gmp_randstate_t state;
    gmp_randinit_default(state);
    time_t t;
    mpz_t *tmp;
    srand((unsigned) time(&t));
    unsigned long seed = rand();
    gmp_randseed_ui(state, seed);
    mpz_urandomm(rndelement, state, thss->prime);
    //mpz_set(,tmp);
    gmp_randclear(state);
}
void Thss_Config(DscThss *thss, int secparam_bits, int total, int threshold)
{
    thss->num_bits=secparam_bits;
    thss->num_shares=total;
    thss->threshold=threshold;


    thss->shares_x = (mpz_t*)malloc(thss->num_shares * sizeof(mpz_t));
    thss->shares_y = (mpz_t*)malloc(thss->num_shares * sizeof(mpz_t));
    mpz_init(thss->recovered_secret);
    thss->coeffs = (mpz_t*)malloc((thss->threshold) * sizeof(mpz_t));
    mpz_init(thss->prime);
}
// initilized thss->prime, thss->secret and coefficients of the polynomial (coef[0] = secret)
// all are in Z_prime*
void Thss_KeyGen(DscThss *thss)
{
    //generate_random_prime(thss); 
    
    gmp_randstate_t state;
    gmp_randinit_default(state);
    time_t t;
    srand((unsigned) time(&t));
    unsigned long seed = rand();
    gmp_randseed_ui(state, seed);
    
    mpz_t random_num;
    mpz_init(random_num);
    mpz_urandomb(random_num, state, thss->num_bits);
    
    mpz_nextprime(thss->prime, random_num);
    
    mpz_clear(random_num);
    gmp_randclear(state);
    
    
    mpz_init(thss->secret);
    generate_random_mpz(thss,thss->secret);

    for (int i = 0; i < thss->threshold; i++) {
        mpz_init(thss->coeffs[i]);
    }
    mpz_set(thss->coeffs[0], thss->secret);

    for (int i = 1; i <= (thss->threshold - 1); i++) {
        mpz_init(thss->coeffs[i]);
        generate_random_mpz(thss, thss->coeffs[i]);
    }
}
//find (thss->num_shares) points on the polynomial
void Thss_Share(DscThss *thss)
{
    mpz_t x;
    mpz_init(x);
    for (int i = 0; i < thss->num_shares; i++) {
        mpz_set_ui(x, i + 1); // مقادیر x باید منحصر به فرد باشند
        mpz_init(thss->shares_x[i]);
        mpz_init(thss->shares_y[i]);
        mpz_set(thss->shares_x[i], x);
        mpz_set_ui(thss->shares_y[i], 0);
        mpz_t term;
        mpz_init(term);

        for (int j = thss->threshold - 1; j >= 0; j--) {
            mpz_mul(term, thss->shares_y[i], thss->shares_x[i]);        
            mpz_mod(term, term, thss->prime);    
            mpz_add(thss->shares_y[i], term, thss->coeffs[j]);
            mpz_mod(thss->shares_y[i], thss->shares_y[i], thss->prime);
        }
        mpz_clear(term);
    }
    mpz_clear(x);
    for(int i =0; i<thss->threshold;i++){
        mpz_clear(thss->coeffs[i]);
    }
    free(thss->coeffs);
}
void Thss_ReCons(DscThss *thss)
{
    mpz_set_ui(thss->recovered_secret, 0);
    mpz_t term;
    mpz_init(term);
    mpz_t numerator;
    mpz_init(numerator);
    mpz_t denominator;
    mpz_init(denominator);
    mpz_t temp;
    mpz_init(temp);

    for (int i = 0; i < thss->threshold; i++) {
        mpz_set_ui(term, 1);
        for (int j = 0; j < thss->threshold; j++) {
            if (i != j) {
                mpz_sub(numerator, thss->shares_x[j], thss->shares_x[i]);
                mpz_set(denominator, numerator);
                mpz_set_ui(temp, 0);
                mpz_add(temp, temp, thss->shares_x[j]);
                mpz_mul(term, term, temp);
                mpz_mod(term, term, thss->prime);
                mpz_invert(denominator, denominator, thss->prime);
                mpz_mul(term, term, denominator);
                mpz_mod(term, term, thss->prime);
            }
        }
        mpz_mul(term, term, thss->shares_y[i]);
        mpz_mod(term, term, thss->prime);
        mpz_add(thss->recovered_secret, thss->recovered_secret, term);
        mpz_mod(thss->recovered_secret, thss->recovered_secret, thss->prime);
    }
    for (int i = 0; i < thss->threshold; i++) {
        mpz_clear(thss->shares_x[i]);
        mpz_clear(thss->shares_y[i]);
    }
    free(thss->shares_x);
    free(thss->shares_y);
    mpz_clear(term);
    mpz_clear(numerator);
    mpz_clear(denominator);
    mpz_clear(temp);
}
//###############################


//###### ThrCrypt=(DKeyGen,Enc,Dec) (Shamir Secret Sharing)
void ThrCrypt_Config(DscThrCrypt *thrcrypt,int secparam_bits,int total, int thrshld) {

    thrcrypt->secparam_bits=secparam_bits;
    char *str="1234";
    thrcrypt->plaintextInput=malloc(strlen(str)*sizeof(char) + 1);
    strcpy(thrcrypt->plaintextInput,str);

    Thss_Config(&(thrcrypt->thss),secparam_bits,total,thrshld);
    thrcrypt->partialDectypted=malloc((&(thrcrypt->thss))->threshold * sizeof(mpz_t));
    thrcrypt->plaintextOutput=malloc(2*strlen(thrcrypt->plaintextInput));

    GroupGen_Config(&(thrcrypt->grp));
    thrcrypt->grp.secparam=secparam_bits;

    mpz_init(thrcrypt->pkey);
    mpz_init(thrcrypt->skey);
    mpz_init(thrcrypt->input);
    mpz_init(thrcrypt->output1);
    mpz_init(thrcrypt->output2);
    mpz_init(thrcrypt->dectypted);
}

void ThrCrypt_DKeyGen(DscThrCrypt *thrcrypt){
    GroupGen(&(thrcrypt->grp));
    Thss_KeyGen(&(thrcrypt->thss));

   // Thss_KeyGen(&(thrcrypt->thss));
    mpz_set(thrcrypt->thss.prime,thrcrypt->grp.prime);
    generate_random_mpz(&(thrcrypt->thss),thrcrypt->thss.secret);
    

    for (int i = 0; i < thrcrypt->thss.threshold; i++) {
        mpz_init(thrcrypt->thss.coeffs[i]);
    }
    mpz_set(thrcrypt->thss.coeffs[0], thrcrypt->thss.secret);

    for (int i = 1; i <= (thrcrypt->thss.threshold - 1); i++) {
        mpz_init(thrcrypt->thss.coeffs[i]);
        generate_random_mpz(&(thrcrypt->thss), thrcrypt->thss.coeffs[i]);
    }

    mpz_set(thrcrypt->skey,thrcrypt->thss.secret);
    mpz_powm(thrcrypt->pkey, thrcrypt->grp.generator, thrcrypt->skey, thrcrypt->thss.prime);
    mpz_set(thrcrypt->thss.secret,thrcrypt->skey);
    Thss_Share(&(thrcrypt->thss));
}
void ThrCrypt_ENC(DscThrCrypt *thrcrypt){

    mpz_import(thrcrypt->input, strlen(thrcrypt->plaintextInput), 1, sizeof(char), 0, 0, thrcrypt->plaintextInput);

    mpz_t r;
    mpz_init(r); 
    mpz_urandomm(r,thrcrypt->grp.state, thrcrypt->grp.generator);

    // c1 = g^k mod p
    mpz_powm(thrcrypt->output1, thrcrypt->grp.generator,r, thrcrypt->grp.prime);

    // c2 = m * y^k mod p
    mpz_powm(thrcrypt->output2, thrcrypt->pkey, r, thrcrypt->grp.prime);
    mpz_mul(thrcrypt->output2, thrcrypt->output2, thrcrypt->input);
    mpz_mod(thrcrypt->output2, thrcrypt->output2, thrcrypt->grp.prime);

}
void ThrCrypt_Dec(DscThrCrypt *thrcrypt)
{
    mpz_set_ui(thrcrypt->thss.recovered_secret, 0);
    mpz_t term;
    mpz_init(term);
    mpz_t numerator;
    mpz_init(numerator);
    mpz_t denominator;
    mpz_init(denominator);
    mpz_t temp;
    mpz_init(temp);

    for (int i = 0; i < thrcrypt->thss.threshold; i++) {
        mpz_set_ui(term, 1);
        mpz_init(thrcrypt->partialDectypted[i]);
        for (int j = 0; j < thrcrypt->thss.threshold; j++) {
            if (i != j) {
                 mpz_sub(numerator, thrcrypt->thss.shares_x[j], thrcrypt->thss.shares_x[i]);
                 mpz_set(denominator, numerator);
                mpz_set_ui(temp, 0);
                mpz_add(temp, temp, thrcrypt->thss.shares_x[j]);
                 mpz_mul(term, term, temp);
                 mpz_mod(term, term, thrcrypt->grp.prime);
                mpz_invert(denominator, denominator, thrcrypt->grp.prime);
                 mpz_mul(term, term, denominator);
                 mpz_mod(term, term, thrcrypt->grp.prime);
            }
        }
        mpz_mul(term, term, thrcrypt->thss.shares_y[i]);
        mpz_mod(thrcrypt->partialDectypted[i], term, (thrcrypt->grp.prime));
        mpz_add(thrcrypt->thss.recovered_secret, thrcrypt->thss.recovered_secret, term);
        mpz_mod(thrcrypt->thss.recovered_secret, thrcrypt->thss.recovered_secret, (thrcrypt->grp.prime));
    }

    mpz_t s, m;
    mpz_init(s);
    mpz_init(m);
    
    mpz_powm(s, thrcrypt->output1, thrcrypt->thss.recovered_secret, thrcrypt->grp.prime);

    mpz_invert(s, s, thrcrypt->grp.prime);
    mpz_mul(m, thrcrypt->output2, s);
    mpz_init(thrcrypt->dectypted);
    mpz_mod(thrcrypt->dectypted, m, thrcrypt->grp.prime);
    
    size_t count;
    mpz_export(thrcrypt->plaintextOutput, &count, 1, sizeof(char), 0, 0, thrcrypt->dectypted);
    thrcrypt->plaintextOutput[count] = '\0';
  
}
//###############################


//###### KAgree=(Setup,Gen,Agree) (In Group G1, and between two parties)
void KAgree_Config(DscKAgree *kagree)
{
    kagree->secparam=16;
    kagree->numUsers=5;

    kagree->sharedSecret=malloc(kagree->numUsers * sizeof(mpz_t *));
    for (int i = 0; i < kagree->numUsers; i++)
    {
       kagree->sharedSecret[i]=malloc(sizeof(mpz_t));
    }
    kagree->user=malloc(kagree->numUsers * sizeof(DscUser));
}

void KAgree_Setup(DscKAgree *kagree)
{
    GroupGen_Config(&(kagree->grp));
    GroupGen(&(kagree->grp));
}
void KAgree_Gen(DscKAgree *kagree, int uid)
{
    if (uid<0 || uid>kagree->numUsers)
    {
        printf("\nuid given is incorrect.\n");
    }
    else
    {
        mpz_init(kagree->user[uid].skey);
        mpz_init(kagree->user[uid].pkey);

        gmp_randstate_t state;
        gmp_randinit_default(state);
        time_t t;
        mpz_t *tmp;
        srand((unsigned) time(&t));
        unsigned long seed = rand();
        gmp_randseed_ui(state, seed);
        mpz_urandomm(kagree->user[uid].skey, state, kagree->grp.prime);
        gmp_randclear(state);
        mpz_powm(kagree->user[uid].pkey, (&(kagree->grp))->generator, kagree->user[uid].skey,kagree->grp.prime);
        mpz_mod(kagree->user[uid].pkey,kagree->user[uid].pkey,kagree->grp.prime);
    }
}
void KAgree_Agree(DscKAgree *kagree,int MyUid, int OthUid)
{
    mpz_init(kagree->sharedSecret[MyUid][OthUid]);
    mpz_powm(kagree->sharedSecret[MyUid][OthUid],kagree->user[OthUid].pkey,kagree->user[MyUid].skey,kagree->grp.prime);
}
//###############################

//###### KAgreeV1=(Setup,Gen,Agree) (In Group G1, and between two parties)

void generate_random_mpz_kagree(DscKAgreeV1 *kagree, mpz_ptr rndelement) {
    //gmp_randstate_t state;
    //gmp_randinit_default(state);
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts); // Get a high-resolution timestamp
    srand((unsigned) ts.tv_nsec);        // Use nanoseconds as a seed
    unsigned long seed = rand();
    //printf("seed %ld\n",seed);

    gmp_randseed_ui(kagree->grp.state, seed);
    mpz_urandomm(rndelement, kagree->grp.state, kagree->grp.prime);
    //gmp_randclear(kagree->grp.state);


   
}


void KAgreeV1_Config(DscKAgreeV1 *kagree)
{
   // kagree->secparam=16;
    //kagree->numUsers=5;



    kagree->sharedSecret=malloc(kagree->numUsers * sizeof(mpz_t));
    kagree->pkey=malloc(kagree->numUsers * sizeof(mpz_t));

    if (!kagree->pkey || !kagree->sharedSecret) {
        printf("Memory allocation failed!\n");
        exit(1);
    }

    for (int i = 0; i < kagree->numUsers; i++)
    {                                                                                                                                                                                                                                                                                                                                                                                                               
       mpz_init(kagree->pkey[i]);
       mpz_init(kagree->sharedSecret[i]);
    }
    mpz_init(kagree->skey);
    GroupGen_Config(&(kagree->grp));
}

void KAgreeV1_Setup(DscKAgreeV1 *kagree)
{
    GroupGen(&(kagree->grp));                                                                                                                                                                                                                   
}

void KAgreeV1_Gen(DscKAgreeV1 *kagree)
{
    /*gmp_randstate_t state;
    gmp_randinit_default(state);
    time_t t;
    mpz_t *tmp;
    srand((unsigned) time(&t));
    unsigned long seed = rand();
    gmp_randseed_ui(state, seed);*/
    generate_random_mpz_kagree(kagree,kagree->skey);
    

    mpz_t tmp1;
    
    for (int i = 0; i < kagree->numUsers; i++)
    {
        mpz_init(tmp1);
        generate_random_mpz_kagree(kagree,tmp1);
        gmp_printf("Random:  %Zd\n", tmp1);
        mpz_powm(kagree->pkey[i], (kagree->grp).generator, tmp1,kagree->grp.prime);
        //mpz_mod(kagree->pkey[i],kagree->pkey[i],kagree->grp.prime);
    }
}

void KAgreeV1_Agree(DscKAgreeV1 *kagree)
{
    for (int i = 0; i < kagree->numUsers; i++)
    {
        mpz_powm(kagree->sharedSecret[i],kagree->pkey[i],kagree->skey,kagree->grp.prime);
    }
}
