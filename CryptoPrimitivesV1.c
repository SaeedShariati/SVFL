#include "CryptoPrimitivesV1.h"
#include <gmp.h>
#include <pbc/pbc.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <time.h>
#include <tomcrypt.h>
#include <unistd.h>
#include <stdint.h>
#include <openssl/evp.h>
#include <openssl/hmac.h>

// ############ Time Measurement ############
void Time_Measure(DscTimeMeasure *time) {
  time->seconds = time->end.tv_sec - time->start.tv_sec;
  time->nanoseconds = time->end.tv_nsec - time->start.tv_nsec;

  if (time->nanoseconds < 0) {
    time->seconds -= 1;
    time->nanoseconds += 1000000000;
  }

  time->milliseconds = time->seconds * 1000 + time->nanoseconds / 1000000;
  time->microseconds = time->seconds * 1000000 + time->nanoseconds / 1000;
}
// ############################################

// ############ Space Measurement ############
void Space_Measure(DscSpaceMeasure *space) {
  space->sizeInBytes = element_length_in_bytes(space->var);
  space->sizeInBit = space->sizeInBytes * 8;
  space->sizeInKBytes = space->sizeInBytes / 1024.0;
  space->sizeInMBytes = space->sizeInBytes / (1024.0 * 1024.0);
}
// ############################################

// ############ HMAC=(KeyGen,Eval) ############
void HMAC_Config(DscHMAC *hmac, int secparam) {
  hmac->secparam = secparam;
  hmac->plaintextInput = "I am a computer science student";
  hmac->DigestOutput = malloc(32);
  hmac->key = malloc(hmac->secparam);
}
void HMAC_KeyGen(DscHMAC *hmac) {
  if (rng_get_bytes((unsigned char *)hmac->key, hmac->secparam, NULL) !=
      hmac->secparam) {
    printf("Error generating random key\n");
  }
}
void HMAC_Eval(DscHMAC *hmac) {
  int err;

  register_hash(&sha256_desc);
  hmac->output_len = 32;
  err = hmac_memory(find_hash("sha256"), (unsigned char *)hmac->key,
                    hmac->secparam, (unsigned char *)hmac->plaintextInput,
                    strlen((const char *)hmac->plaintextInput),
                    hmac->DigestOutput, &(hmac->output_len));

  if (err != CRYPT_OK) {
    printf("Error performing HMAC: %s\n", error_to_string(err));
  }
}
void HMAC_Free(DscHMAC *hmac) {
  free(hmac->DigestOutput);
  free(hmac->key);
}
// ############################################

// ############ PRF=(KeyGen,Eval) #############

//secparam in bytes
void PRF_Config(DscPRF *prf, int secparam) {
  prf->secparam = secparam;
  prf->randomOutput = malloc(32);
  prf->key = malloc(prf->secparam);
}
void PRF_KeyGen(DscPRF *prf) {
  if (rng_get_bytes((unsigned char *)prf->key, prf->secparam, NULL) !=
      prf->secparam) {
    printf("Error generating random key\n");
  }
}
void PRF_Eval(DscPRF *prf,char* message,uint32_t size) {
  int err;
  prf->plaintextInput = message;
  unsigned long output_len = 32;
  register_hash(&sha256_desc);
  err = hmac_memory(find_hash("sha256"), (unsigned char *)prf->key,
                    prf->secparam, (unsigned char *)message,
                    size,
                    prf->randomOutput, &(output_len));

  if (err != CRYPT_OK) {
    printf("Error performing PRF: %s\n", error_to_string(err));
  }
}
void PRF_Free(DscPRF *prf) {
  free(prf->key);
  free(prf->randomOutput);
}

/* 16 bytes key
void PRG(uint8_t *out, size_t outlen, const uint8_t *seed16) {
  EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
  uint8_t iv[16] = {0};
  
  EVP_EncryptInit_ex(ctx, EVP_aes_128_ctr(), NULL, seed16, iv);
  memset(out,0,20);
  int len;
  EVP_EncryptUpdate(ctx, out, &len, out, outlen);  // encrypt zeros
  EVP_CIPHER_CTX_free(ctx);
}
*/

//outlen is in bytes
void PRG(uint8_t *out, size_t outlen, const uint8_t *key32) {
  EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
  uint8_t iv[16] = {0};  // 128-bit IV (can also be passed as a parameter)

  EVP_EncryptInit_ex(ctx, EVP_aes_256_ctr(), NULL, key32, iv);
  memset(out, 0, outlen);
  int len;
  EVP_EncryptUpdate(ctx, out, &len, out, outlen);
  EVP_CIPHER_CTX_free(ctx);
}
void PRF(
    uint8_t out[32],
    const uint8_t *key, size_t keylen,
    const uint8_t *input, size_t inputlen
) {
    unsigned int outlen = 32;
    HMAC(EVP_sha256(), key, keylen, input, inputlen, out, &outlen);
}
// ############ PRG=(SeedGen,Eval) ############
//secparam here is in  bytes
void PRG_Config(DscPRG *prg, int secparam, uint32_t size) {
  prg->secparam = secparam;
  prg->size = size;
}
void PRG_SeedGen(DscPRG *prg) {
  (&(prg->hmac))->secparam = prg->secparam;
  (&(prg->hmac))->plaintextInput =
  malloc(strlen("An inital value          ") + 1);
  strcpy((&(prg->hmac))->plaintextInput, "An inital value          ");
  (&(prg->hmac))->DigestOutput = malloc(32);
  (&(prg->hmac))->key = malloc((&(prg->hmac))->secparam);
  //(&(prg->hmac))->output_len = 16;
  prg->randomOutput = malloc(prg->size);
  HMAC_KeyGen((&(prg->hmac)));
}
void PRG_Eval(DscPRG *prg) {
  unsigned long generated = 0;         // Counter for generated bytes
  unsigned long remaining = prg->size; // Remaining bytes to generate
  uint16_t counter = 0; // Counter for HMAC input
  unsigned long bytes_to_copy = 0;
  while (remaining > 0) {
    memcpy(prg->hmac.plaintextInput + 15, &counter, 2);
    HMAC_Eval(&(prg->hmac));
    bytes_to_copy = (remaining < 32) ? remaining : 32;
    memcpy(prg->randomOutput + generated, prg->hmac.DigestOutput,
           bytes_to_copy);
    generated += bytes_to_copy;
    remaining -= bytes_to_copy;
    counter++;
  }
}
void PRG_Free(DscPRG *prg) {
  free(prg->randomOutput);
  HMAC_Free(&(prg->hmac));
  free(prg->hmac.plaintextInput);
}

// ############ Hash=(Eval) ############
void Hash_Config(DscHash *hash, int secparam) {
  /*SHA1:   register_hash (&sha1_desc);
  SHA224: register_hash (&sha224_desc);
  SHA256: register_hash (&sha256_desc);
  SHA384: register_hash (&sha384_desc);
  SHA512: register_hash (&sha512_desc);
  MD2:    register_hash (&md2_desc);
  MD4:    register_hash (&md4_desc);
  MD5:    register_hash (&md5_desc);*/
  hash->secparam = secparam;
  hash->DigestOutput = malloc(32); // Adjust buffer size for safety
  register_hash(&sha256_desc);
  hash->hash_name = "sha256";
}
void Hash_Eval(DscHash *hash,char* plaintext,uint32_t size) {
  int err, hash_idx;

  hash->plaintextInput = plaintext;

  hash_idx = find_hash(hash->hash_name);
  if (hash_idx == -1) {
    printf("Invalid hash function name: %s\n", hash->hash_name);
    exit(EXIT_FAILURE);
  }

  // Set the output length for the found hash function
  hash->output_len = hash_descriptor[hash_idx].hashsize;

  // Compute the hash
  err = hash_memory(hash_idx, (unsigned char *)hash->plaintextInput,
                    size,hash->DigestOutput, &(hash->output_len));
  if (err != CRYPT_OK) {
    printf("Error performing hash: %s\n", error_to_string(err));
    exit(EXIT_FAILURE);
  }
}
void Hash_Free(DscHash* hash){
  free(hash->DigestOutput);
}
// ###############################
// initilizes prime, generator and order and sets secparam=512 bits
void GroupGen_Config(DscGrp *grp, uint32_t secparam) {
  grp->secparam = secparam;
  mpz_init(grp->prime);
  mpz_init(grp->generator);
  mpz_init(grp->order);
}
// generates Z_p* with generator = 2, and p is a safe prime (p=2q+1 where q is a
// prime)
void GroupGen(DscGrp *grp) {
  // Generate a random safe prime number (p = 2q + 1)
  mpz_t q, test;
  gmp_randinit_default(grp->state);
  gmp_randseed_ui(grp->state, time(NULL));
  mpz_inits(q, test, NULL);

  while (1) {
    // Generate random 511-bit prime q
    mpz_urandomb(q, grp->state, grp->secparam - 1);
    mpz_setbit(q, grp->secparam - 2); // ensure it's secparam-1 bits

    mpz_nextprime(q, q);
    // q might be a secparam bit prime,if so, so p will be secparam+1 bit prime,
    // might cause buffer overlfow somewhere in the code

    mpz_mul_ui(grp->prime, q, 2);
    mpz_add_ui(grp->prime, grp->prime, 1);

    if (mpz_probab_prime_p(grp->prime, 25) > 0) {
      mpz_set_ui(test, 2);
      mpz_powm(test, test, q, grp->prime);

      if (mpz_cmp_ui(test, 1) != 0) {
        mpz_set_ui(grp->generator, 2);
        mpz_sub_ui(grp->order, grp->prime, 1);
        break;
      }
    }
  }

  mpz_clears(q, test, NULL);
}
void GroupGen_Free(DscGrp* grp){
  mpz_clears(grp->prime,grp->generator,grp->order,NULL);
  gmp_randclear(grp->state);
}

void generatePrime(mpz_ptr rop, uint32_t sizeInBits){
  gmp_randstate_t state;
  gmp_randinit_default(state);
  gmp_randseed_ui(state, time(NULL));

  mpz_urandomb(rop, state, sizeInBits);
  mpz_nextprime(rop, rop);
  gmp_randclear(state);
}
// ############ BGroupGen  ############
void BGroupGen_Config(DscBGrp *bgrp) {
  bgrp->paramSize = 2048;
  bgrp->paramAddress = "d224.param";
}
void BGroupGen(DscBGrp *bgrp) {
  char param[bgrp->paramSize]; // Adjust size if needed
  FILE *param_file;

  // Load parameters from d224.param file
  param_file = fopen(bgrp->paramAddress, "r");
  if (!param_file) {
    pbc_die("Error opening param file.");
  }
  size_t count = fread(param, 1, sizeof(param), param_file);
  if (count == 0) {
    pbc_die("Error reading param file.");
    fclose(param_file);
  }
  pairing_init_set_buf(bgrp->pairing, param, count);
  fclose(param_file);
  mpz_init(bgrp->order);
  mpz_set(bgrp->order, (bgrp->pairing)->r);

  element_init_G1(bgrp->g1, bgrp->pairing);
  element_init_G2(bgrp->g2, bgrp->pairing);
  element_init_GT(bgrp->gt, bgrp->pairing);
  element_random(bgrp->g1);
  element_random(bgrp->g2);
  element_random(bgrp->gt);

  element_init_G1(bgrp->rg1, bgrp->pairing);
  element_init_G2(bgrp->rg2, bgrp->pairing);
  element_init_GT(bgrp->rgt, bgrp->pairing);
  element_init_Zr(bgrp->rz, bgrp->pairing);
  element_random(bgrp->rg1);
  element_random(bgrp->rg2);
  element_random(bgrp->rgt);
  element_random(bgrp->rz);
}


// initializes rndelement with a random value less than prime
void generate_random_mpz(mpz_ptr prime, mpz_ptr rndelement) {
  // Initialize LibTomCrypt PRNG
  int prng_idx = register_prng(&sprng_desc);
  if (prng_idx == -1) {
    fprintf(stderr, "Error registering sprng\n");
  }

  prng_state prng;
  if (sprng_start(&prng) != CRYPT_OK || sprng_ready(&prng) != CRYPT_OK) {
    fprintf(stderr, "Error initializing sprng\n");
  }

  size_t num_bytes = (mpz_sizeinbase(prime, 2) + 7) / 8;
  unsigned char *buffer = malloc(num_bytes);
  if (!buffer) {
    fprintf(stderr, "Memory allocation failed\n");
  }

  mpz_t temp;
  mpz_init(temp);

  do {
    // Generate cryptographically secure random bytes
    if (sprng_read(buffer, num_bytes, NULL) != num_bytes) {
      fprintf(stderr, "sprng_read failed\n");
      free(buffer);
    }

    // Convert buffer to mpz_t
    mpz_import(temp, num_bytes, 1, 1, 0, 0, buffer);

  } while (mpz_cmp(temp, prime) > 0); // Retry if temp > q

  mpz_set(rndelement, temp);

  mpz_clear(temp);
  free(buffer);
}
// ###### Thrss=(Share,ReConst) (Shamir Secret Sharing)
void Thss_Config(DscThss *thss, int secparam_bits, int total, int threshold) {
  thss->num_bits = secparam_bits;
  thss->num_shares = total;
  thss->threshold = threshold;

  thss->shares_x = (mpz_t *)malloc(thss->num_shares * sizeof(mpz_t));
  thss->shares_y = (mpz_t *)malloc(thss->num_shares * sizeof(mpz_t));
  mpz_init(thss->recovered_secret);
  thss->coeffs = (mpz_t *)malloc((thss->threshold) * sizeof(mpz_t));
  mpz_init(thss->prime);
}
// initilized thss->prime, if the prime argument is Null then generates a prime
void Thss_KeyGen(DscThss *thss, mpz_ptr prime) {
  // generate_random_prime(thss);
  if (prime) {
    mpz_set(thss->prime, prime);
  } else {
    gmp_randstate_t state;
    gmp_randinit_default(state);
    time_t t;
    srand((unsigned)time(&t));
    unsigned long seed = rand();
    gmp_randseed_ui(state, seed);

    mpz_t random_num;
    mpz_init(random_num);
    mpz_urandomb(random_num, state, thss->num_bits);

    mpz_nextprime(thss->prime, random_num);

    mpz_clear(random_num);
    gmp_randclear(state);
  }
}
// find (thss->num_shares) points on the polynomial, if secret is NULL then
// generates one randomly
void Thss_Share(DscThss *thss, mpz_ptr secret) {
  mpz_init(thss->secret);
  if (!secret) {
    generate_random_mpz(thss->prime, thss->secret);
  } else {
    mpz_set(thss->secret, secret);
  }
  mpz_init(thss->coeffs[0]);
  mpz_set(thss->coeffs[0], thss->secret);

  for (int i = 1; i < thss->threshold; i++) {
    mpz_init(thss->coeffs[i]);
    generate_random_mpz(thss->prime, thss->coeffs[i]);
  }

  mpz_t x;
  mpz_init(x);
  for (int i = 0; i < thss->num_shares; i++) {
    mpz_set_ui(x, i + 1); // مقادیر x باید منحصر به فرد باشند
    mpz_init(thss->shares_x[i]);
    mpz_init(thss->shares_y[i]);
    mpz_set(thss->shares_x[i], x);
    mpz_set_ui(thss->shares_y[i], 0);
    mpz_t term;
    mpz_init(term);

    for (int j = thss->threshold - 1; j >= 0; j--) {
      mpz_mul(term, thss->shares_y[i], thss->shares_x[i]);
      mpz_mod(term, term, thss->prime);
      mpz_add(thss->shares_y[i], term, thss->coeffs[j]);
      mpz_mod(thss->shares_y[i], thss->shares_y[i], thss->prime);
    }
    mpz_clear(term);
  }
  mpz_clear(x);
  for (int i = 0; i < thss->threshold; i++) {
    mpz_clear(thss->coeffs[i]);
  }

}
void Thss_ReCons(DscThss *thss) {
  mpz_set_ui(thss->recovered_secret, 0);
  mpz_t term, numerator, denominator, temp;
  mpz_inits(term, numerator, denominator, temp, NULL);

  for (int i = 0; i < thss->threshold; i++) {
    mpz_set_ui(term, 1);
    for (int j = 0; j < thss->threshold; j++) {
      if (i != j) {
        mpz_sub(numerator, thss->shares_x[j], thss->shares_x[i]);
        mpz_set(denominator, numerator);
        mpz_set_ui(temp, 0);
        mpz_add(temp, temp, thss->shares_x[j]);
        mpz_mul(term, term, temp);
        mpz_mod(term, term, thss->prime);
        mpz_invert(denominator, denominator, thss->prime);
        mpz_mul(term, term, denominator);
        mpz_mod(term, term, thss->prime);
      }
    }
    mpz_mul(term, term, thss->shares_y[i]);
    mpz_mod(term, term, thss->prime);
    mpz_add(thss->recovered_secret, thss->recovered_secret, term);
    mpz_mod(thss->recovered_secret, thss->recovered_secret, thss->prime);
  }

  mpz_clears(term, numerator, denominator, temp, NULL);
}
void Thss_Free(DscThss *thss) {
  mpz_clears(thss->secret, thss->prime, thss->recovered_secret, NULL);
  free(thss->coeffs);
    for (int i = 0; i < thss->num_shares; i++) {
    mpz_clear(thss->shares_x[i]);
    mpz_clear(thss->shares_y[i]);
  }
  free(thss->shares_x);
  free(thss->shares_y);
}
// ###############################
//###### ThrCrypt=(DKeyGen,Enc,Dec) (Threshold Elgamal Cryptosystem)
void ThrCrypt_Enc_Block(DscThrCrypt *thrcrypt,char* plaintext, uint32_t size, uint32_t blockNumber);
void ThrCrypt_Dec_Block(DscThrCrypt *thrcrypt, uint32_t blockNumber);
uint16_t decode_mpz_as_byteArray(char* rop, mpz_ptr integer);
void encode_bytes_as_mpz(mpz_ptr rop, char *byteArray, uint32_t size);

void ThrCrypt_Config(DscThrCrypt *thrcrypt,uint16_t secparam_bits,uint16_t total, uint16_t threshold) {

    thrcrypt->secparam_bits=secparam_bits;
    thrcrypt->maximumBlockSize = (u_int16_t)(thrcrypt->secparam_bits/8 -2);
    Thss_Config(&(thrcrypt->thss),secparam_bits,total,threshold);
    GroupGen_Config(&(thrcrypt->grp),secparam_bits);
    mpz_inits(thrcrypt->pkey,thrcrypt->skey,NULL);
}

void ThrCrypt_DKeyGen(DscThrCrypt *thrcrypt){
  GroupGen(&(thrcrypt->grp));
  Thss_KeyGen(&(thrcrypt->thss),thrcrypt->grp.prime);
  Thss_Share(&(thrcrypt->thss),NULL);

  mpz_set(thrcrypt->skey,thrcrypt->thss.secret);
  mpz_powm(thrcrypt->pkey, thrcrypt->grp.generator, thrcrypt->skey, thrcrypt->thss.prime);
}
//plaintext can be any series of bytes, doesn't have to be a string, size is in bytes
void ThrCrypt_Enc(DscThrCrypt *thrcrypt,char* plaintext, uint32_t size){
  thrcrypt->cipher.blocks=(uint32_t)((size+thrcrypt->maximumBlockSize-1)/thrcrypt->maximumBlockSize);
  thrcrypt->plaintextInput = malloc(size);
  memcpy(thrcrypt->plaintextInput,plaintext,size);

  uint32_t blockCount = thrcrypt->cipher.blocks;
  thrcrypt->cipher.output1 = (mpz_t*)malloc(blockCount*sizeof(mpz_t));
  thrcrypt->cipher.output2 = (mpz_t*)malloc(blockCount*sizeof(mpz_t));

  for(int block =0;block<blockCount-1;block++){
    mpz_inits(thrcrypt->cipher.output1[block],thrcrypt->cipher.output2[block],NULL);
    ThrCrypt_Enc_Block(thrcrypt,plaintext+block*(thrcrypt->maximumBlockSize)
      ,thrcrypt->maximumBlockSize,block);
  }
  mpz_inits(thrcrypt->cipher.output1[blockCount-1],thrcrypt->cipher.output2[blockCount-1],NULL);
  ThrCrypt_Enc_Block(thrcrypt, plaintext+(blockCount-1)*thrcrypt->maximumBlockSize
    ,size - (blockCount-1)*thrcrypt->maximumBlockSize, blockCount-1);

  free(thrcrypt->plaintextInput);

}
void ThrCrypt_Enc_Block(DscThrCrypt *thrcrypt,char* plaintext, uint32_t size, uint32_t blockNumber){
  mpz_t input;
  mpz_init(input);
  encode_bytes_as_mpz(input, plaintext, size);

  mpz_t k;
  mpz_init(k); 
  mpz_urandomm(k,thrcrypt->grp.state, thrcrypt->grp.generator);

  // c1 = g^k mod p
  mpz_powm(thrcrypt->cipher.output1[blockNumber], thrcrypt->grp.generator,k, thrcrypt->grp.prime);

  // c2 = m * y^k mod p
  mpz_powm(thrcrypt->cipher.output2[blockNumber], thrcrypt->pkey, k, thrcrypt->grp.prime);
  mpz_mul(thrcrypt->cipher.output2[blockNumber], thrcrypt->cipher.output2[blockNumber], input);
  mpz_mod(thrcrypt->cipher.output2[blockNumber], thrcrypt->cipher.output2[blockNumber], thrcrypt->grp.prime);
  mpz_clear(input);
  mpz_clear(k);
}
void ThrCrypt_Dec(DscThrCrypt *thrcrypt)
{
  thrcrypt->sizeOfPlaintext = 0;
  mpz_set_ui(thrcrypt->thss.recovered_secret, 0);
  mpz_t term, numerator, denominator, temp;
  mpz_inits(term, numerator, denominator, temp, NULL);

  for (int i = 0; i < thrcrypt->thss.threshold; i++) {
    mpz_set_ui(term, 1);
    //mpz_init(thrcrypt->partialDecrypted[i]);
    for (int j = 0; j < thrcrypt->thss.threshold; j++) {
      if (i != j) {
        mpz_sub(numerator, thrcrypt->thss.shares_x[j],
                thrcrypt->thss.shares_x[i]);
        mpz_set(denominator, numerator);
        mpz_set_ui(temp, 0);
        mpz_add(temp, temp, thrcrypt->thss.shares_x[j]);
        mpz_mul(term, term, temp);
        mpz_mod(term, term, thrcrypt->grp.prime);
        mpz_invert(denominator, denominator, thrcrypt->grp.prime);
        mpz_mul(term, term, denominator);
        mpz_mod(term, term, thrcrypt->grp.prime);
      }
    }
    mpz_mul(term, term, thrcrypt->thss.shares_y[i]);
    mpz_mod(term,term,thrcrypt->grp.prime);
    mpz_add(thrcrypt->thss.recovered_secret, thrcrypt->thss.recovered_secret,
            term);
    mpz_mod(thrcrypt->thss.recovered_secret, thrcrypt->thss.recovered_secret,
            (thrcrypt->grp.prime));
  }
  mpz_clears(term, numerator, denominator, temp, NULL);

  for(int block=0;block<thrcrypt->cipher.blocks;block++){
    ThrCrypt_Dec_Block(thrcrypt, block);
  }
  thrcrypt->plaintextOutput = realloc(thrcrypt->plaintextOutput,thrcrypt->sizeOfPlaintext);
}
void ThrCrypt_Dec_Block(DscThrCrypt *thrcrypt, uint32_t blockNumber)
{
  mpz_t s, m;
  mpz_inits(s,m,NULL);
  
  mpz_powm(s, thrcrypt->cipher.output1[blockNumber], thrcrypt->thss.recovered_secret, thrcrypt->grp.prime);
  mpz_invert(s, s, thrcrypt->grp.prime);
  mpz_mul(m, thrcrypt->cipher.output2[blockNumber], s);
  mpz_mod(m, m, thrcrypt->grp.prime);
  if(blockNumber==0){
    uint16_t bytes = mpz_size(m) * sizeof(mp_limb_t);
    thrcrypt->plaintextOutput = malloc((bytes-1)*thrcrypt->cipher.blocks);
  }
  thrcrypt->sizeOfPlaintext += 
    decode_mpz_as_byteArray(thrcrypt->plaintextOutput + blockNumber*thrcrypt->maximumBlockSize, m);
  mpz_clears(s,m,NULL);;
}
void ThrCrypt_Free(DscThrCrypt *thrcrypt) {
  mpz_clears(thrcrypt->skey,thrcrypt->pkey,NULL);
  GroupGen_Free(&(thrcrypt->grp));
  Thss_Free(&(thrcrypt->thss));
}
void Cipher_Free(DscCipher* cipher){
  for(int i=0;i<cipher->blocks;i++){
    mpz_clears(cipher->output1[i],cipher->output2[i],NULL);
  }
  free(cipher->output1);
  free(cipher->output2);
}
//convert byteArray with the specified size to mpz_t (rop must be initialized)
void encode_bytes_as_mpz(mpz_ptr rop, char *byteArray, uint32_t size) {
  char* paddedMessage = malloc(size + 1);
  paddedMessage[0] = 1; // padding(because mpz_t ignores leading zeros so we add a nonzero byte at the start)
  memcpy(paddedMessage+1, byteArray, size); //actual message
  mpz_import(rop, size+1, 1, sizeof(char), 0, 0,
              paddedMessage);
  free(paddedMessage);
}
//converts back the padded integer to byteArray(returns bytes read)
uint16_t decode_mpz_as_byteArray(char* rop, mpz_ptr integer){
  //size_t bytes = mpz_size(integer) * sizeof(mp_limb_t);
  size_t bytes = (mpz_sizeinbase(integer, 2) + 7) / 8;

  char* paddedMessage = malloc(bytes);
  mpz_export(paddedMessage, &bytes, 1, sizeof(char), 0, 0, integer);
  memcpy(rop, paddedMessage + 1, bytes - 1);
  free(paddedMessage);
  return bytes-1;
}
